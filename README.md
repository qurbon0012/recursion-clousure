# recursion-clousure
recursion clousure
Рекурсия (Recursion) и Замыкания (Closure) в JavaScript
Рекурсия и замыкания — это два важнейших концепта в JavaScript, которые часто используются для решения разнообразных задач. Давайте подробно рассмотрим каждый из этих понятий.
1. Рекурсия (Recursion)
Рекурсия — это процесс, при котором функция вызывает саму себя. В рекурсивной функции всегда должна быть базовая (терминальная) ситуация, чтобы избежать бесконечного вызова самой себя.

Основные моменты о рекурсии:
Функция вызывает саму себя.
Обычно используется для решения задач, которые можно разбить на более простые аналогичные задачи (например, факториал, Fibonacci).

Важно иметь базовое условие (условие завершения), чтобы избежать бесконечных рекурсивных вызовов.
Пример: Факториал числа
function factorial(n) {
  if (n === 0) {  // базовый случай: факториал 0 равен 1
    return 1;
  }
  return n * factorial(n - 1);  // рекурсивный вызов
}

console.log(factorial(5));  // Output: 120 (5 * 4 * 3 * 2 * 1)

В этом примере:

Базовый случай: когда n === 0, функция возвращает 1, прекращая рекурсию.
Рекурсивный случай: функция вызывает себя, уменьшая n на 1, пока не достигнет базового случая.
Пример: Числа Фибоначчи
function fibonacci(n) {
  if (n <= 1) {
    return n;
  }
  return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(6));  // Output: 8 (1, 1, 2, 3, 5, 8)

Здесь:

Базовый случай: если n <= 1, возвращаем n.
Рекурсивный случай: функция вызывает себя дважды, чтобы вычислить два предыдущих числа в последовательности.
Важные моменты:
Рекурсия используется, когда задача имеет структуру, которая может быть решена путём повторяющихся шагов.
Каждый рекурсивный вызов создает новый контекст выполнения (новое состояние), и каждый вызов должен в какой-то момент закончиться (базовый случай).

#2. Замыкания (Closure)
Замыкание — это функция, которая "запоминает" своё лексическое окружение, даже если она вызывается за пределами своей области видимости. Это позволяет функции сохранять доступ к переменным, которые были определены вне её тела, но в пределах родительской функции.

Замыкания являются важной частью JavaScript, потому что они позволяют работать с приватными данными и создавать функции с сохранённым состоянием.
Числа Фибоначчи — это последовательность, где каждое следующее число равно сумме двух предыдущих.

Основные моменты о замыканиях:
Функция "запоминает" контекст, в котором была создана, включая переменные из внешней области видимости.
Замыкания могут использоваться для инкапсуляции данных и создания приватных переменных.
Пример: Простейшее замыкание
function outer() {
  let outerVar = "I am outside!";
  
  function inner() {
    console.log(outerVar);  // inner() имеет доступ к outerVar
  }
  
  return inner;  // возвращаем функцию inner
}

const closureExample = outer();
closureExample();  // Output: I am outside!

В этом примере:

Функция inner является замыканием, потому что она "запоминает" переменную outerVar, даже когда она вызывается за пределами функции outer.
Пример: Сохранение состояния с помощью замыкания
Замыкания часто используются для создания "приватных" переменных, доступных только через функции.

function counter() {
  let count = 0;  // Приватная переменная
  
  return {
    increment: function() {
      count++;
      return count;
    },
    decrement: function() {
      count--;
      return count;
    },
    getCount: function() {
      return count;
    }
  };
}

const myCounter = counter();
console.log(myCounter.increment());  // Output: 1
console.log(myCounter.increment());  // Output: 2
console.log(myCounter.getCount());  // Output: 2
console.log(myCounter.decrement());  // Output: 1

Здесь:

Функция counter создает и возвращает объект с тремя методами.
Каждый метод имеет доступ к приватной переменной count, которая недоступна напрямую извне.
Замыкание позволяет сохранять и изменять значение переменной count между вызовами методов, создавая своего рода "приватное" состояние.

Важные моменты:
Замыкания позволяют функции "запоминать" состояние и работать с ним даже после завершения выполнения родительской функции.
Замыкания могут использоваться для реализации приватных данных и инкапсуляции.
